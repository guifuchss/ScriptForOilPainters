import tkinter as tk
from tkinter import messagebox, filedialog
import numpy as np
from colour import SpectralDistribution, XYZ_to_sRGB, sd_to_XYZ, sRGB_to_XYZ
from PIL import Image, ImageTk, ImageOps
import os
from scipy.optimize import minimize

class PaintMixingGame:
    def __init__(self, master):
        self.master = master
        master.title("Jogo de Mistura de Tintas a Óleo")

        # Carregar a textura de tinta padrão
        texture_path = r"E:\PythonCodes\Projetos\ScriptForOilPainters\texture_oil\pngtree-textured-background-with-brush-stroke-of-gray-oil-paint-image_13659816.png"
        try:
            if not os.path.exists(texture_path):
                raise FileNotFoundError("A imagem de textura não foi encontrada no caminho especificado.")
            self.texture_image = Image.open(texture_path).convert('RGBA')
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao carregar a imagem de textura:\n{e}")
            self.texture_image = None  # Defina como None ou uma imagem padrão

        self.texture_photo = None  # Para manter a referência da imagem
        self.saved_tones = []  # Armazena os tons criados

        # Dados espectrais aproximados para as tintas
        self.available_paints_spectral = {
            'Amarelo Ocre': self.create_spectral_distribution('Amarelo Ocre'),
            'Vermelho Cádmio': self.create_spectral_distribution('Vermelho Cádmio'),
            'Azul Ultramarino': self.create_spectral_distribution('Azul Ultramarino'),
            'Branco de Titânio': self.create_spectral_distribution('Branco de Titânio'),
            'Preto Marfim': self.create_spectral_distribution('Preto Marfim'),
            'Verde Viridian': self.create_spectral_distribution('Verde Viridian'),
            'Siena Queimada': self.create_spectral_distribution('Siena Queimada'),
            'Alizarin Crimson': self.create_spectral_distribution('Alizarin Crimson'),
            'Amarelo Limão': self.create_spectral_distribution('Amarelo Limão'),
            'Siena Natural': self.create_spectral_distribution('Siena Natural'),
            'Terra de Sombra Queimada': self.create_spectral_distribution('Terra de Sombra Queimada'),
            'Azul Cobalto': self.create_spectral_distribution('Azul Cobalto'),
            'Azul Cerúleo': self.create_spectral_distribution('Azul Cerúleo'),
            'Amarelo Cádmio': self.create_spectral_distribution('Amarelo Cádmio'),
            'Cinza de Payne': self.create_spectral_distribution('Cinza de Payne'),
            'Verde Ftalocianina': self.create_spectral_distribution('Verde Ftalocianina'),
            'Azul Ftalocianina': self.create_spectral_distribution('Azul Ftalocianina'),
            'Magenta Quinacridona': self.create_spectral_distribution('Magenta Quinacridona'),
            'Amarelo Nápoles': self.create_spectral_distribution('Amarelo Nápoles'),
            'Vermelho Índio': self.create_spectral_distribution('Vermelho Índio'),
        }

        self.selected_paints = {}
        self.mistura = []  # Armazena tuplas (sd, quantidade)

        self.background_color = None
        self.background_image = None
        self.bg_image_label = None

        self.create_selection_interface()

    def create_spectral_distribution(self, paint_name):
        wavelengths = np.arange(380, 781, 5)

        if paint_name == 'Amarelo Ocre':
            values = np.exp(-0.001 * (wavelengths - 580) ** 2)
        elif paint_name == 'Vermelho Cádmio':
            values = np.exp(-0.001 * (wavelengths - 610) ** 2)
        elif paint_name == 'Azul Ultramarino':
            values = np.exp(-0.001 * (wavelengths - 450) ** 2)
        elif paint_name == 'Branco de Titânio':
            values = np.ones_like(wavelengths)
        elif paint_name == 'Preto Marfim':
            values = np.zeros_like(wavelengths)
        elif paint_name == 'Verde Viridian':
            values = np.exp(-0.001 * (wavelengths - 530) ** 2)
        elif paint_name == 'Siena Queimada':
            values = np.exp(-0.001 * (wavelengths - 600) ** 2) * 0.8
        elif paint_name == 'Alizarin Crimson':
            values = np.exp(-0.001 * (wavelengths - 640) ** 2)
        elif paint_name == 'Amarelo Limão':
            values = np.exp(-0.001 * (wavelengths - 570) ** 2)
        elif paint_name == 'Siena Natural':
            values = np.exp(-0.001 * (wavelengths - 580) ** 2) * 0.85
        elif paint_name == 'Terra de Sombra Queimada':
            values = np.exp(-0.001 * (wavelengths - 600) ** 2) * 0.75
        elif paint_name == 'Azul Cobalto':
            values = np.exp(-0.001 * (wavelengths - 480) ** 2)
        elif paint_name == 'Azul Cerúleo':
            values = np.exp(-0.001 * (wavelengths - 500) ** 2)
        elif paint_name == 'Amarelo Cádmio':
            values = np.exp(-0.001 * (wavelengths - 580) ** 2)
        elif paint_name == 'Cinza de Payne':
            values = np.ones_like(wavelengths) * 0.6
        elif paint_name == 'Verde Ftalocianina':
            values = np.exp(-0.001 * (wavelengths - 520) ** 2)
        elif paint_name == 'Azul Ftalocianina':
            values = np.exp(-0.001 * (wavelengths - 460) ** 2)
        elif paint_name == 'Magenta Quinacridona':
            values = np.exp(-0.001 * (wavelengths - 610) ** 2)
        elif paint_name == 'Amarelo Nápoles':
            values = np.exp(-0.001 * (wavelengths - 580) ** 2) * 0.9
        elif paint_name == 'Vermelho Índio':
            values = np.exp(-0.001 * (wavelengths - 620) ** 2)
        else:
            values = np.ones_like(wavelengths) * 0.5

        sd = SpectralDistribution(values, wavelengths)
        return sd

    def create_selection_interface(self):
        self.clear_window()

        tk.Label(self.master, text="Selecione as tintas para sua paleta:").pack()

        self.paint_vars = {}
        for paint in self.available_paints_spectral.keys():
            var = tk.IntVar()
            cb = tk.Checkbutton(self.master, text=paint, variable=var)
            cb.pack(anchor='w')
            self.paint_vars[paint] = var

        self.create_palette_button = tk.Button(self.master, text="Criar Paleta", command=self.create_palette)
        self.create_palette_button.pack(pady=10)

    def create_palette(self):
        self.selected_paints = {paint: sd for paint, var in self.paint_vars.items() if var.get() == 1 for sd in [self.available_paints_spectral[paint]]}
        if not self.selected_paints:
            messagebox.showwarning("Aviso", "Nenhuma tinta selecionada!")
            return
        self.mistura = []
        self.create_palette_interface()

    def create_palette_interface(self):
        self.clear_window()

        # Configurar a janela para tela cheia
        self.master.attributes('-fullscreen', True)

        # Criar frames para organizar a interface
        main_frame = tk.Frame(self.master)
        main_frame.pack(fill='both', expand=True)

        # Frames laterais
        left_frame = tk.Frame(main_frame)
        left_frame.pack(side='left', fill='both', expand=True)

        right_frame = tk.Frame(main_frame)
        right_frame.pack(side='right', fill='both', expand=True)

        # Frame superior para as tintas
        paints_frame = tk.Frame(main_frame)
        paints_frame.pack(side='top', fill='x')

        # Exibir as tintas selecionadas com controles
        for paint in self.selected_paints.keys():
            paint_frame = tk.Frame(paints_frame)
            paint_frame.pack(side='left', padx=5, pady=5)

            rgb = self.sd_to_rgb(self.selected_paints[paint])
            paint_texture_photo = self.get_colored_texture(rgb, size=(50, 50))

            color_label = tk.Label(paint_frame, image=paint_texture_photo)
            color_label.pack()
            color_label.image = paint_texture_photo

            tk.Label(paint_frame, text=paint, font=("Helvetica", 10)).pack()

            # Controle de quantidade de tinta para cada cor
            quantity_var = tk.DoubleVar(value=0.0)
            quantity_scale = tk.Scale(paint_frame, from_=0.0, to=1.0, resolution=0.05, orient='horizontal', variable=quantity_var)
            quantity_scale.pack()

            add_button = tk.Button(paint_frame, text="+", command=lambda p=paint, q=quantity_var: self.add_to_mistura(p, q.get()))
            add_button.pack()

        # Área para exibir a mistura atual
        mistura_label = tk.Label(left_frame, text="Mistura Atual:", font=("Helvetica", 14))
        mistura_label.pack(pady=10)

        self.mistura_image_label = tk.Label(left_frame)
        self.mistura_image_label.pack()

        # Botão de "Refresh" para resetar a mistura
        refresh_button = tk.Button(left_frame, text="Resetar Mistura", command=self.reset_mistura, font=("Helvetica", 12))
        refresh_button.pack(pady=10)

        # Área para exibir a cor extraída
        extracted_label = tk.Label(right_frame, text="Cor Extraída:", font=("Helvetica", 14))
        extracted_label.pack(pady=10)

        self.extracted_color_label = tk.Label(right_frame)
        self.extracted_color_label.pack()

        # Botão para fazer upload de imagem
        upload_button = tk.Button(right_frame, text="Upload de Imagem", command=self.upload_image, font=("Helvetica", 12))
        upload_button.pack(pady=10)

        # Área para exibir a imagem
        self.image_label = tk.Label(right_frame)
        self.image_label.pack()

        # Área para exibir informações da mistura
        self.info_label = tk.Label(left_frame, text="", font=("Helvetica", 12))
        self.info_label.pack(pady=10)

        # Botão para voltar à seleção de tintas
        self.back_button = tk.Button(self.master, text="Voltar", command=self.create_selection_interface)
        self.back_button.pack(side='bottom', pady=10)

    def reset_mistura(self):
        self.mistura = []
        self.mistura_image_label.config(image='')  # Resetar a imagem da mistura
        self.info_label.config(text="Mistura resetada.")

    def add_to_mistura(self, paint, intensity):
        if intensity <= 0:
            messagebox.showwarning("Aviso", "A quantidade deve ser maior que zero.")
            return
        sd = self.selected_paints[paint]
        self.mistura.append((sd, intensity))
        mistura_sd = self.calculate_mistura_spectral()
        rgb = self.sd_to_rgb(mistura_sd)
        self.apply_color_to_texture(rgb, self.mistura_image_label)
        # Atualizar informações da mistura
        mixture_info = ""
        total_intensity = sum([qty for _, qty in self.mistura])
        for sd, qty in self.mistura:
            paint_name = [name for name, s in self.selected_paints.items() if s == sd][0]
            percentage = (qty / total_intensity) * 100
            mixture_info += f"{percentage:.1f}% {paint_name}\n"
        self.info_label.config(text=mixture_info)

    def upload_image(self):
        image_path = filedialog.askopenfilename(title="Selecione a Imagem", filetypes=[("Arquivos de Imagem", "*.png;*.jpg;*.jpeg;*.bmp")])
        if image_path:
            self.reference_image = Image.open(image_path)
            # Redimensionar a imagem para caber em uma área específica mantendo a proporção
            max_width = 400
            max_height = 400
            self.reference_image.thumbnail((max_width, max_height), Image.LANCZOS)
            self.reference_photo = ImageTk.PhotoImage(self.reference_image)
            self.image_label.config(image=self.reference_photo)
            self.image_label.image = self.reference_photo
            self.image_label.bind("<Button-1>", self.on_image_click)

    def on_image_click(self, event):
        x = event.x
        y = event.y

        # Obter o tamanho atual da imagem exibida
        displayed_width = self.reference_photo.width()
        displayed_height = self.reference_photo.height()

        # Calcular a proporção entre a imagem original e a exibida
        original_width, original_height = self.reference_image.size
        scale_x = original_width / displayed_width
        scale_y = original_height / displayed_height

        # Ajustar as coordenadas para corresponder à imagem original
        x_original = int(x * scale_x)
        y_original = int(y * scale_y)

        # Garantir que as coordenadas estejam dentro dos limites da imagem
        x_original = min(max(x_original, 0), original_width - 1)
        y_original = min(max(y_original, 0), original_height - 1)

        rgb = self.reference_image.getpixel((x_original, y_original))

        # Ajustar rgb para garantir que seja uma tupla de três inteiros
        if isinstance(rgb, int):
            # Imagem em escala de cinza
            rgb = (rgb, rgb, rgb)
        elif len(rgb) == 4:
            # Imagem com canal alfa
            rgb = rgb[:3]
        elif len(rgb) == 3:
            pass  # RGB já está correto
        else:
            messagebox.showerror("Erro", "Formato de cor desconhecido.")
            return

        # Converter valores para inteiros
        rgb = tuple(int(c) for c in rgb)

        # Exibir a cor extraída com a textura
        self.apply_color_to_texture(rgb, self.extracted_color_label)

    def calculate_mistura_spectral(self):
        if not self.mistura:
            return SpectralDistribution(np.ones(81), np.arange(380, 781, 5))

        epsilon = 1e-6
        absorbances = []
        weights = []
        for sd, intensity in self.mistura:
            absorbance = -np.log10(sd.values + epsilon)
            absorbances.append(absorbance)
            weights.append(intensity)

        weights = np.array(weights)
        weights /= np.sum(weights)

        avg_absorbance = np.average(absorbances, axis=0, weights=weights)
        mistura_reflectance = 10 ** (-avg_absorbance)

        mistura_sd = SpectralDistribution(mistura_reflectance, self.mistura[0][0].domain)
        return mistura_sd

    def sd_to_rgb(self, sd):
        xyz = sd_to_XYZ(sd)
        rgb = XYZ_to_sRGB(xyz / 100)
        rgb = np.clip(rgb, 0, 1) * 255
        return tuple(rgb.astype(int))

    def apply_color_to_texture(self, rgb, label_widget):
        # Garantir que rgb seja uma tupla de três inteiros
        rgb = tuple(int(c) for c in rgb[:3])
        if self.texture_image is None:
            color_image = Image.new('RGB', (200, 200), rgb)
            texture_photo = ImageTk.PhotoImage(color_image)
        else:
            grayscale_texture = self.texture_image.convert('L')
            rgb_hex = '#%02x%02x%02x' % rgb
            colored_texture = ImageOps.colorize(grayscale_texture, black="black", white=rgb_hex)
            colored_texture = colored_texture.resize((200, 200), Image.LANCZOS)
            texture_photo = ImageTk.PhotoImage(colored_texture)

        label_widget.config(image=texture_photo)
        label_widget.image = texture_photo

    def get_colored_texture(self, rgb, size=(100, 100)):
        # Garantir que rgb seja uma tupla de três inteiros
        rgb = tuple(int(c) for c in rgb[:3])
        if self.texture_image is None:
            color_image = Image.new('RGB', size, rgb)
            return ImageTk.PhotoImage(color_image)

        grayscale_texture = self.texture_image.convert('L')
        rgb_hex = '#%02x%02x%02x' % rgb
        colored_texture = ImageOps.colorize(grayscale_texture, black="black", white=rgb_hex)
        colored_texture = colored_texture.resize(size, Image.LANCZOS)
        return ImageTk.PhotoImage(colored_texture)

    def clear_window(self):
        for widget in self.master.winfo_children():
            widget.destroy()
        if self.bg_image_label:
            self.bg_image_label.destroy()
            self.bg_image_label = None

    def start(self):
        self.master.mainloop()

root = tk.Tk()
game = PaintMixingGame(root)
game.start()
