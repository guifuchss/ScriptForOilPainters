import tkinter as tk
from tkinter import messagebox, colorchooser, filedialog
import numpy as np
from colour import SpectralDistribution, XYZ_to_sRGB, sd_to_XYZ
from PIL import Image, ImageTk, ImageOps
import os

class PaintMixingGame:
    def __init__(self, master):
        self.master = master
        master.title("Jogo de Mistura de Tintas a Óleo")

        # Dados espectrais aproximados para as tintas
        self.available_paints_spectral = {
            'Amarelo Ocre': self.create_spectral_distribution('Amarelo Ocre'),
            'Vermelho Cádmio': self.create_spectral_distribution('Vermelho Cádmio'),
            'Azul Ultramarino': self.create_spectral_distribution('Azul Ultramarino'),
            'Branco de Titânio': self.create_spectral_distribution('Branco de Titânio'),
            'Preto Marfim': self.create_spectral_distribution('Preto Marfim'),
            'Verde Viridian': self.create_spectral_distribution('Verde Viridian'),
            'Siena Queimada': self.create_spectral_distribution('Siena Queimada'),
            'Alizarin Crimson': self.create_spectral_distribution('Alizarin Crimson'),
            'Amarelo Limão': self.create_spectral_distribution('Amarelo Limão'),
            'Siena Natural': self.create_spectral_distribution('Siena Natural'),
            'Terra de Sombra Queimada': self.create_spectral_distribution('Terra de Sombra Queimada'),
            'Azul Cobalto': self.create_spectral_distribution('Azul Cobalto'),
            'Azul Cerúleo': self.create_spectral_distribution('Azul Cerúleo'),
            'Amarelo Cádmio': self.create_spectral_distribution('Amarelo Cádmio'),
            'Cinza de Payne': self.create_spectral_distribution('Cinza de Payne'),
            'Verde Ftalocianina': self.create_spectral_distribution('Verde Ftalocianina'),
            'Azul Ftalocianina': self.create_spectral_distribution('Azul Ftalocianina'),
            'Magenta Quinacridona': self.create_spectral_distribution('Magenta Quinacridona'),
            'Amarelo Nápoles': self.create_spectral_distribution('Amarelo Nápoles'),
            'Vermelho Índio': self.create_spectral_distribution('Vermelho Índio'),
        }

        self.selected_paints = {}
        self.mistura = []  # Agora armazenará tuplas (sd, intensidade)

        self.background_color = None
        self.background_image = None
        self.bg_image_label = None

        # Carregar a textura de tinta padrão
        texture_path = r"E:\PythonCodes\Projetos\texture_oil\pngtree-textured-background-with-brush-stroke-of-gray-oil-paint-image_13659816.png"
        try:
            if not os.path.exists(texture_path):
                raise FileNotFoundError("A imagem de textura não foi encontrada no caminho especificado.")
            self.texture_image = Image.open(texture_path).convert('RGBA')
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao carregar a imagem de textura:\n{e}")
            self.texture_image = None  # Defina como None ou uma imagem padrão

        self.texture_photo = None  # Para manter a referência da imagem

        self.create_selection_interface()

    def create_spectral_distribution(self, paint_name):
        # Cria uma distribuição espectral genérica para a tinta
        # Esta é uma simplificação; para precisão, dados espectrais reais são necessários

        wavelengths = np.arange(380, 781, 5)

        if paint_name == 'Amarelo Ocre':
            values = np.exp(-0.001 * (wavelengths - 580) ** 2)
        elif paint_name == 'Vermelho Cádmio':
            values = np.exp(-0.001 * (wavelengths - 610) ** 2)
        elif paint_name == 'Azul Ultramarino':
            values = np.exp(-0.001 * (wavelengths - 450) ** 2)
        elif paint_name == 'Branco de Titânio':
            values = np.ones_like(wavelengths)
        elif paint_name == 'Preto Marfim':
            values = np.zeros_like(wavelengths)
        elif paint_name == 'Verde Viridian':
            values = np.exp(-0.001 * (wavelengths - 530) ** 2)
        elif paint_name == 'Siena Queimada':
            values = np.exp(-0.001 * (wavelengths - 600) ** 2) * 0.6
        elif paint_name == 'Alizarin Crimson':
            values = np.exp(-0.001 * (wavelengths - 640) ** 2)
        elif paint_name == 'Amarelo Limão':
            values = np.exp(-0.001 * (wavelengths - 570) ** 2)
        elif paint_name == 'Siena Natural':
            values = np.exp(-0.001 * (wavelengths - 580) ** 2) * 0.7
        elif paint_name == 'Terra de Sombra Queimada':
            values = np.exp(-0.001 * (wavelengths - 600) ** 2) * 0.4
        elif paint_name == 'Azul Cobalto':
            values = np.exp(-0.001 * (wavelengths - 480) ** 2)
        elif paint_name == 'Azul Cerúleo':
            values = np.exp(-0.001 * (wavelengths - 500) ** 2)
        elif paint_name == 'Amarelo Cádmio':
            values = np.exp(-0.001 * (wavelengths - 580) ** 2)
        elif paint_name == 'Cinza de Payne':
            values = np.ones_like(wavelengths) * 0.5
        elif paint_name == 'Verde Ftalocianina':
            values = np.exp(-0.001 * (wavelengths - 520) ** 2)
        elif paint_name == 'Azul Ftalocianina':
            values = np.exp(-0.001 * (wavelengths - 460) ** 2)
        elif paint_name == 'Magenta Quinacridona':
            values = np.exp(-0.001 * (wavelengths - 610) ** 2)
        elif paint_name == 'Amarelo Nápoles':
            values = np.exp(-0.001 * (wavelengths - 580) ** 2) * 0.9
        elif paint_name == 'Vermelho Índio':
            values = np.exp(-0.001 * (wavelengths - 620) ** 2)
        else:
            # Para outras tintas, usar uma distribuição neutra
            values = np.ones_like(wavelengths) * 0.5

        sd = SpectralDistribution(values, wavelengths)
        return sd

    def create_selection_interface(self):
        # [O restante do método permanece o mesmo]
        self.clear_window()

        tk.Label(self.master, text="Selecione as tintas para sua paleta:").pack()

        self.paint_vars = {}
        for paint in self.available_paints_spectral.keys():
            var = tk.IntVar()
            cb = tk.Checkbutton(self.master, text=paint, variable=var)
            cb.pack(anchor='w')
            self.paint_vars[paint] = var

        self.add_paint_button = tk.Button(self.master, text="Adicionar Nova Tinta", command=self.add_new_paint)
        self.add_paint_button.pack()

        self.create_palette_button = tk.Button(self.master, text="Criar Paleta", command=self.create_palette)
        self.create_palette_button.pack()

    def add_new_paint(self):
        # [O restante do método permanece o mesmo]
        messagebox.showinfo("Aviso", "A adição de novas tintas não é suportada nesta versão.")

    def create_palette(self):
        # [O restante do método permanece o mesmo]
        self.selected_paints = {paint: sd for paint, var in self.paint_vars.items() if var.get() == 1 for sd in [self.available_paints_spectral[paint]]}
        if not self.selected_paints:
            messagebox.showwarning("Aviso", "Nenhuma tinta selecionada!")
            return
        self.mistura = []
        self.create_palette_interface()

    def create_palette_interface(self):
        self.clear_window()

        if self.background_color:
            self.master.config(bg=self.background_color)
        elif self.background_image:
            pass  # A imagem de fundo já está configurada
        else:
            self.master.config(bg='SystemButtonFace')

        palette_frame = tk.Frame(self.master)
        palette_frame.pack()

        for paint in self.selected_paints.keys():
            paint_frame = tk.Frame(palette_frame)
            paint_frame.pack(side='left', padx=10)

            # Obter a cor RGB da tinta
            rgb = self.sd_to_rgb(self.selected_paints[paint])

            # Aplicar a cor à textura
            paint_texture_photo = self.get_colored_texture(rgb)

            color_label = tk.Label(paint_frame, image=paint_texture_photo)
            color_label.pack()

            # Manter referência para evitar garbage collection
            color_label.image = paint_texture_photo

            # Modificar o botão "+" para chamar uma função que seleciona a intensidade
            add_button = tk.Button(paint_frame, text="+", command=lambda p=paint: self.select_intensity_and_add(p))
            add_button.pack()

        mistura_frame = tk.Frame(self.master)
        mistura_frame.pack(pady=20)

        tk.Label(mistura_frame, text="Mistura Central:").pack()

        # Inicializar o label da imagem da mistura
        self.mistura_image_label = tk.Label(mistura_frame)
        self.mistura_image_label.pack()

        self.info_label = tk.Label(self.master, text="")
        self.info_label.pack(pady=10)

        self.color_info_label = tk.Label(self.master, text="RGB: (255, 255, 255)")
        self.color_info_label.pack()

        self.customize_bg_button = tk.Button(self.master, text="Personalizar Fundo", command=self.customize_background)
        self.customize_bg_button.pack(pady=10)

    def select_intensity_and_add(self, paint):
        intensity_window = tk.Toplevel(self.master)
        intensity_window.title("Selecione a Intensidade")
        tk.Label(intensity_window, text=f"Selecione a intensidade para {paint}:").pack(pady=10)

        # Variável para armazenar a intensidade selecionada
        intensity_var = tk.DoubleVar(value=1.0)  # Valor padrão é 1.0 (100%)

        # Opções de intensidade
        intensities = [1.0, 0.75, 0.5, 0.25]
        intensity_labels = ['100%', '75%', '50%', '25%']

        for val, label in zip(intensities, intensity_labels):
            tk.Radiobutton(intensity_window, text=label, variable=intensity_var, value=val).pack(anchor='w')

        # Botão para confirmar a seleção
        confirm_button = tk.Button(intensity_window, text="Adicionar", command=lambda: self.confirm_add_paint(paint, intensity_var.get(), intensity_window))
        confirm_button.pack(pady=10)

    def confirm_add_paint(self, paint, intensity, window):
        # Fechar a janela de seleção de intensidade
        window.destroy()
        # Adicionar a tinta à mistura com a intensidade selecionada
        self.add_to_mistura(paint, intensity)

    def add_to_mistura(self, paint, intensity=1.0):
        sd = self.selected_paints[paint]
        # Armazenar a tinta com a intensidade
        self.mistura.append((sd, intensity))
        mistura_sd = self.calculate_mistura_spectral()
        rgb = self.sd_to_rgb(mistura_sd)
        rgb_text = f"RGB: {rgb}"
        self.info_label.config(text=f"Foi adicionada a tinta {paint} com intensidade {int(intensity * 100)}%")
        self.color_info_label.config(text=rgb_text)

        # Aplicar a cor resultante à textura
        self.apply_color_to_texture(rgb)

    def calculate_mistura_spectral(self):
        if not self.mistura:
            # Retornar branco se nenhuma tinta foi adicionada
            return SpectralDistribution(np.ones(81), np.arange(380, 781, 5))

        # Converter reflectância em absorbância
        epsilon = 1e-6
        absorbances = []
        weights = []
        for sd, intensity in self.mistura:
            absorbance = -np.log10(sd.values + epsilon)
            absorbances.append(absorbance)
            weights.append(intensity)

        # Converter pesos para numpy array
        weights = np.array(weights)
        # Normalizar pesos
        weights /= np.sum(weights)

        # Calcular a média ponderada das absorbâncias
        avg_absorbance = np.average(absorbances, axis=0, weights=weights)

        # Converter absorbância média de volta para reflectância
        mistura_reflectance = 10 ** (-avg_absorbance)

        mistura_sd = SpectralDistribution(mistura_reflectance, self.mistura[0][0].domain)
        return mistura_sd

    def sd_to_rgb(self, sd):
        # Converter distribuição espectral para XYZ
        xyz = sd_to_XYZ(sd)
        # Converter XYZ para sRGB
        rgb = XYZ_to_sRGB(xyz / 100)
        # Clampear valores e converter para 0-255
        rgb = np.clip(rgb, 0, 1) * 255
        return tuple(rgb.astype(int))

    def sd_to_hex(self, sd):
        rgb = self.sd_to_rgb(sd)
        return '#%02x%02x%02x' % rgb

    def get_colored_texture(self, rgb):
        if self.texture_image is None:
            # Retorna uma imagem sólida se a textura não estiver disponível
            color_image = Image.new('RGB', (50, 50), rgb)
            return ImageTk.PhotoImage(color_image)

        # Converter a textura para escala de cinza
        grayscale_texture = self.texture_image.convert('L')

        # Converter o valor RGB para uma string hexadecimal
        rgb_hex = '#%02x%02x%02x' % rgb

        # Aplicar a cor à textura
        colored_texture = ImageOps.colorize(grayscale_texture, black="black", white=rgb_hex)

        # Redimensionar a imagem para caber no label
        colored_texture = colored_texture.resize((50, 50), Image.LANCZOS)

        # Converter para PhotoImage para exibição no Tkinter
        texture_photo = ImageTk.PhotoImage(colored_texture)

        return texture_photo

    def apply_color_to_texture(self, rgb):
        if self.texture_image is None:
            # Se a textura não estiver disponível, mostrar uma cor sólida
            color_image = Image.new('RGB', (200, 200), rgb)
            self.texture_photo = ImageTk.PhotoImage(color_image)
        else:
            # Converter a textura para escala de cinza
            grayscale_texture = self.texture_image.convert('L')

            # Converter o valor RGB para uma string hexadecimal
            rgb_hex = '#%02x%02x%02x' % rgb

            # Aplicar a cor à textura usando ImageOps.colorize
            colored_texture = ImageOps.colorize(grayscale_texture, black="black", white=rgb_hex)

            # Redimensionar a imagem para o tamanho desejado
            colored_texture = colored_texture.resize((200, 200), Image.LANCZOS)

            # Converter para PhotoImage para exibição no Tkinter
            self.texture_photo = ImageTk.PhotoImage(colored_texture)

        # Atualizar o label da imagem da mistura
        self.mistura_image_label.config(image=self.texture_photo)
        self.mistura_image_label.image = self.texture_photo  # Manter referência

    def clear_window(self):
        for widget in self.master.winfo_children():
            widget.destroy()
        if self.bg_image_label:
            self.bg_image_label.destroy()
            self.bg_image_label = None

    def start(self):
        self.master.mainloop()

root = tk.Tk()
game = PaintMixingGame(root)
game.start()
